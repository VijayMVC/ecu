# Class features and design issues

## Overview

- Class basics
- Classify roles of function members
- Constructors
- Destructors
- Composition
- Improving classes

# Class basics

- Composed of two files
- Header files
    - `*.h`
    - Class declarations
    - Inline member function implementations
    - Template function implementations
        - `#ifndef`
        - `#define`
        - `#endif`
- Source files
    - `*.cpp`
    - Member function implementations
        - Non inline

``` cpp
// Salesperson.h
#ifndef SALESPERSON_H
#define SALESPERSON_H

class Salesperson
{
    int _id;
    string _name;
public:
    Salesperson(int id, string name);
    void display();
};
```

``` cpp
// Salesperson.cpp
Salesperson::Salesperson(int id, string lastname)
{
    _id = id;
    _name = name;
}

void Salesperson::display()
{
    cout << "Salesperson #" << _id << ' ' << _name << '\n';
}
```

# Classify roles of member functions

## Inspector/access functions

- Return info about an object's state
- Display some or all of an object's attributes

## Predicate functions

- Return `bool`
- Checks something
- ie. `isDigit()`, `isEmpty()`

## Mutator functions

- Change an object's state/attributes
- ie. `setDate()`, `computePrice()`

## Auxillary functions

- Facilitators
- Perform some sort of action or service
- ie. `sortAscending()`, `findLowestValue()`

## Manager functions

- Create/destroy objects
- Constructors/destructors

# Constructors

- Member function that initializes class
- Called automatically when new instance of class is created
- Has same name as class
    - No return type

## Constructor types

- Default
    - No arguments
    - If no constructor specified, compiler generates default constructor automatically
- Non default
    - Has at least one argument
    - Must be explicitly called

## Default constructors

``` cpp
// without default
class Employee
{
    int _id;
    double _rate; // not initialised, will contain garbage on ctr
public:
    void setId(const int id);
    void setRate(const double rate);
    int getId();
    double getRate();
};

int main()
{
    Employee employee; // constructed using default
}
```

``` cpp
class Employee
{
    int _id;
    double _rate;
public:
    Employee();
    void setId(const int id);
    void setRate(const double rate);
    int getId();
    double getRate();
};

// default inits members, no more garbage
Employee::Employee()
{
    _id = 1;
    _rate = 1.5;
}
```

## Non default constructors

- You can overload constructors and have any number of combinations depending on attributes of the class

``` cpp
// default
Employee::Employee()
{
    _id = 1;
    _rate = 1.5;
}

Employee::Employee(int id, double rate)
{
    _id = id;
    _rate = rate;
}

Employee::Employee(int id)
{
    _id = id;
    _rate = 1.5;
}

Employee::Employee(double rate)
{
    _id = 1;
    _rate = rate;
}
```

# Destructors

- Deletes an object
- Called automatically when object goes out of scope
    - When function ends
    - Program ends
    - Block containing temp variable ends
    - Delete operator is called

## Writing destructors

- Same name as class with `~` prefix
    - `~Employee();`
- No arguments/return value
- Automatically generated by compiler if not defined
- Used when class contains a pointer to allocated memory
- Programmers responsibility to release the memory before the class instance is destroyed

## Using destructors

``` cpp
class House
{
    int _sqFt;
public:
    House();
    ~House();
    int getSqFt();
};

House::House()
{
    _sqFt = 1000;
    cout << "House created\n";
}

House::~House()
{
    cout << "House destroyed\n";
}

int House::getSqFt()
{
    return _sqFt;
}

int main()
{
    House house;
    return 0;
} // ~House() called here
```

# Composition

- Composition is using an object within another object or members of classes
- Call the member object's methods

## With default constructors

``` cpp
class InventoryItem
{
    int _id;
    double _price;
public:
    void setId(int id);
    void setPrice(double price);
    void display();
};

class Salesperson
{
    int _id;
    string _name;
public:
    void setId(int id);
    void setName(string name);
    void display();
};

class Transaction
{
    int _id;
    InventoryItem _item;
    Salesperson _seller;
public:
    Transaction(
        int transactionId, 
        int itemId, 
        double itemPrice, 
        int salesPersonId,
        string salesPersonName);
    void display();
};

Transaction::Transaction(
    int transactionId,
    int itemId,
    double itemPrice,
    int salesPersonId,
    string salesPersonName)
{
    _id = transactionId;
    _item.setId(itemId);
    _item.setPrice(itemPrice);
    _seller.setId(salesPersonId);
    _seller.setName(salesPersonName);
}

void Transaction::display()
{
    cout << "Transaction: " << _id << '\n';
    _item.display();
    _seller.display();
}
```

## Without default constructors

``` cpp
class InventoryItem
{
    int _id;
    double _price;
public:
    InventoryItem(int id, double price);
    void display();
};

class Salesperson
{
    int _id;
    string _name;
public:
    Salesperson(int id, string name);
    void display();
};

class Transaction
{
    int _id;
    InventoryItem _item;
    Salesperson _seller;
public:
    Transaction(
        int transactionId, 
        int itemId, 
        double itemPrice, 
        int salesPersonId,
        string salesPersonName);
    void display();
};

Transaction::Transaction(
        int transactionId,
        int itemId,
        double itemPrice,
        int salesPersonId,
        string salesPersonName) :
    _item(itemId, itemPrice), // call ctr
    _seller(salesPersonId, salesPersonName) // call ctr
{
    _id = transactionId;
}

void Transaction::display()
{
    cout << "Transaction: " << _id << '\n';
    _item.display();
    _seller.display();
}
```

# Improving classes

## Naming conventions

- Use meaningful names
    - No: `myInt`, `aFunction()`
- Use pronouncable names
    - No: `zbq`, `gootw()`
- Be judicious in use of abbreviations
    - No: `getStat()`
- Avoid digits
    - `0` (zero) can be confused with `O`
    - `1` (one) can be confused with `l`
    - No: `var1`
    - Yes: `budgetFor2010`
- Use camelcase for multi-word names
    - `initIntegerValues()`
- Include a form of *to be*
    - Like `is`, `are` for variables/methods that have a notion of state
    - Yes: `isOverdrawn`, `isValid()`
- Verb nouns are good for functions
    - Yes: `computeBalance()`, `displayTotal()`
- Can use stubs as placeholder during initial development phase
    - Simple functions that do nothing
    - Helps block out structure

## Coupling and cohesion

### Reduce coupling

- Tightly coupled functions are harder to
    - Write
    - Maintain
    - Reuse
    - Test

### Increase cohesion

- How well the operation in a function relate to one another
- All operations should contribute to the performance of only one task
- Always strive for functional cohesion

``` cpp
double square(double number)
{
    return number * number;
}
```
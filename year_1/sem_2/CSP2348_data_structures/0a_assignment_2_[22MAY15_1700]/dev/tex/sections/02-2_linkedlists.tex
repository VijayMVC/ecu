\newpage
\section{Singly linked lists}

The singly linked list data structure is demonstrated through a list of students which stores their marks for a particular unit. Each node in the singly linked list represents a student. A student's ID number is used as the identifier, while storing results for Assignment 1, Assignment 2 and Exam Result. The list includes functions to insert new students into the list (while maintaining an ascending order based on a student's ID number) and can determine which student has the highest overall mark within the list.

Additional functions have been added to the list, allowing a specific student to be removed from the list, and print the list in reverse, descending order based on student ID numbers. These additional methods have been implemented twice, in two separate packages.

\mintinline{bash}{com.martinponce.csp2348.a2.linkedlistprogramming} maintains the original self-contained and executable class with additional methods \mintinline{bash}{delete_unit_result()} and \mintinline{bash}{reverse_print_unit_result()} appended.

\mintinline{bash}{com.martinponce.csp2348.a2.linkedlistprogramming.alternative} contains a rewrite of the original \mintinline{bash}{UnitList} class attempting to resolve issues with deleting a first node in the original \mintinline{bash}{UnitList} class. Methods shown in this report from the alternative package will be labelled appropriately.
\\
\\
The following classes are created within \\
\mintinline{bash}{com.martinponce.csp2348.a2.linkedlistprogramming.alternative}:

\begin{itemize}
\item \mintinline{bash}{Main}: The executable class, contains \mintinline{bash}{main()} method
\item \mintinline{bash}{UnitList}: Defines the singly linked list header
\item \mintinline{bash}{UnitListNode}: Defines the singly linked list node
\end{itemize}

\newpage
\subsection{Deleting}

In order to delete a specific node from the linked list, the program must be able to search for a key, which in this case is a student ID number. If the key is found within the list, the program will delete that specific node from the list.

For the function to be implemented, a singly linked list deletion algorithm has been created as shown below.

Implementation of the Java method requires a \mintinline{bash}{void} method and therefore cannot return any data. A first node should not be physically deleted, even if it is logically deleted, otherwise the list will lose reference to all other nodes in the list. This will cause all other nodes to be deleted instead.

The exclusion of a variable which tracks the head of the linked list in the original \mintinline{bash}{UnitList} class has caused an issue where the deletion of the first node is not permanent. Therefore, the development of an alternative \mintinline{bash}{UnitList} class is included in this report and source files, which tracks the head, and enables permanent deletion of the first node.

\subsubsection{Delete target node algorithm}

%To delete node \emph{del} in the nonempty SLL headed by \emph{first}:

%\begin{enumerate}
%\item Let \emph{succ} be node \emph{del}'s successor
%\item If \emph{del} = \emph{first}:
%	\begin{enumerate}
%	\item Set \emph{first} to \emph{succ}
%	\end{enumerate}
%\item Otherwise (if \emph{del} $\neq$ \emph{first}):
%	\begin{enumerate}
%	\item Let \emph{pred} be node \emph{del}'s predecessor
%	\item Set node \emph{pred}'s successor to \emph{succ}
%	\end{enumerate}
%\item Terminate
%\end{enumerate}

To delete \emph{del} in SLL headed by \emph{head}:

\begin{enumerate}
\item If SLL is empty:
	\begin{enumerate}
	\item Terminate
	\end{enumerate}
\item Else let \emph{current} be node \emph{head}, and \emph{previous} be null
\item While \emph{current} does not match \emph{del}, repeat:
	\begin{enumerate}
	\item If end of SLL is reached:
		\begin{enumerate}
		\item Terminate
		\end{enumerate}
	\item Else set node \emph{previous} to node \emph{current}
	\item Set node \emph{current} to \emph{current}'s next node
	\end{enumerate}
\item If node to be deleted is first node:
	\begin{enumerate}
	\item Set \emph{head} to \emph{current}'s next node
	\end{enumerate}
\item Else set \emph{previous}'s next node to \emph{current}'s next node
\item Set \emph{current}'s next node to null
\item Terminate
\end{enumerate}

%\noindent
%\citep[p. 83]{Watt2001}

\subsubsection{Delete target node Java method}

\begin{listing}[H]
\caption{Delete target node method}
\begin{javacode}
private static void delete_unit_result(UnitList u_list, int ID) {

    // if list is empty, or ID outside range, print error message and terminate
    if(u_list == null) {
        System.out.println("\nError: List is empty!");
        return;
    } else if(ID < 999 || ID > 9999) {
        System.out.println("\nError: Student number " 
                + ID + " is outside valid range!");
        return;
    }

    // cursors to traverse list
    UnitList current = u_list;
    UnitList previous = null;

    // traverse list
    while(current.student_ID != ID) {

        // if cursor traversed to end of list and target not found,
        if(current.next == null) {

            // print error message
            System.out.println("\nError: Student " 
                    + ID + " not deleted. Student does not exist!");
            return;

        // else continue traversing
        } else {
            previous = current;
            current = current.next;
        }
    }

    // if current is at first node, and target matched
    // implied after exiting while loop and previous being null
    if(previous == null) {

        // TODO: fix issue where "deleted" first node not permanent

        // print action performed
        System.out.println("\nDeleted first student: " + current.student_ID);

        // set list to current next node
        u_list = current.next;

    // else current is somewhere else down the list, and target matched
    } else {

        // print action performed
        System.out.println("\nDeleted student: " + current.student_ID);
        // set previous's next node to current's next node
        previous.next = current.next;
        // set current's next to null
        current.next = null;
    }

    print_unit_result(u_list);
}
\end{javacode}
\end{listing}

\begin{listing}[H]
\caption{Alternative delete target node method}
\begin{javacode}
public void deleteUnitResult(int studentID) {

    // if list is empty,
    if(isEmpty()) {
        // print error message and terminate
        System.out.println("\nError: List is empty!");
        return;

    // else if studentID outside rage,
    } else if(studentID < 999 || studentID > 9999) {
        // print error message and terminate
        System.out.println("\nError: Student " + studentID + " is outside valid range!");
        return;
    }

    // set cursors to start of list
    cursorCurrent = head;
    cursorPrevious = null;

    // while current studentID does not match target studentID
    while(cursorCurrent.getStudentID() != studentID) {

        // if reached end of list,
        if(cursorCurrent.getNext() == null) {
            // print error message and terminate
            System.out.println("\nError: Student " + studentID 
            	+ " not deleted. Student does not exist!");
            return;

        // else continue traversing
        } else {
            cursorPrevious = cursorCurrent;
            cursorCurrent = cursorCurrent.getNext();
        }
    }

    // if targetID found in very first node,
    if(cursorPrevious == null) {

        // set head to current next
        head = cursorCurrent.getNext();
        // print success message
        System.out.println("\nDeleted Student " + studentID + " (first node).");

    // else targetID found somewhere else down the list,
    } else {

        // print success message
        System.out.println("\nDeleted Student " + studentID + ".");
        // set previous next to current next
        cursorPrevious.setNext(cursorCurrent.getNext());
        // set current next to null
        cursorCurrent.setNext(null);
    }
    length--;
}
\end{javacode}
\end{listing}

\noindent
Line 41 in Java code 3.2 shows that an instance variable \mintinline{bash}{head} is set to \mintinline{bash}{cursorCurrent}'s next node, allowing persistent deletion of a first node.

\subsubsection{Delete target node analysis}

Analysis of this singly linked list delete algorithm involves counting traversals. Assuming \emph{current} and \emph{previous} traverse through each node in a single operation, they traverse between 0 to $n - 1$ nodes before finding or not finding the target key. Or $(n - 1) / 2$ times on average. Therefore, the time complexity of this delete algorithm is $O(n)$ \citep[p. 83]{Watt2001}. Space complexity is $O(1)$ since no copies are made.

\subsubsection{Delete target node console output}

The series of console outputs below demonstrates the execution of Java code 3.1, the delete implementation within the original \mintinline{bash}{UnitList} class. It successfully ``deletes'' the first student 1111, but after subsequent calls to the method, student 1111 reappears in the list. However, deletions elsewhere in the list are persistent, as seen with student 1114.
\\
\begin{consolecode}
Deleted first student: 1111

Student_No.: 1112
A1_mark: 10
A2_mark: 6
Exam_mark: 50

Student_No.: 1114
A1_mark: 14
A2_mark: 21
Exam_mark: 30

...
\end{consolecode}

\begin{consolecode}
Deleted student: 1114

Student_No.: 1111
A1_mark: 17
A2_mark: 22
Exam_mark: 30

Student_No.: 1112
A1_mark: 10
A2_mark: 6
Exam_mark: 50

Student_No.: 1116
A1_mark: 8
A2_mark: 16
Exam_mark: 35

...
\end{consolecode}

\begin{consolecode}
Deleted student: 1116

Student_No.: 1111
A1_mark: 17
A2_mark: 22
Exam_mark: 30

Student_No.: 1112
A1_mark: 10
A2_mark: 6
Exam_mark: 50

Student_No.: 1122
A1_mark: 11
A2_mark: 19
Exam_mark: 40

...
\end{consolecode}

\newpage
\noindent
The series of console outputs below demonstrate the execution of Java code 3.2, the deletion implementation within the alternative \mintinline{bash}{UnitList} class. This exhibits a persistent deletion of the first node, or in this case, student 1111.
\\
\begin{consolecode}
Deleted Student 1111 (first node).

Student: 1112
A1 Mark: 10
A2 Mark: 6
Exam Mark: 50
Next Node: 1114

Student: 1114
A1 Mark: 14
A2 Mark: 21
Exam Mark: 30
Next Node: 1116

...
\end{consolecode}

\begin{consolecode}
Deleted Student 1116.

Deleted Student 1145.

Student: 1112
A1 Mark: 10
A2 Mark: 6
Exam Mark: 50
Next Node: 1114

Student: 1114
A1 Mark: 14
A2 Mark: 21
Exam Mark: 30
Next Node: 1122

Student: 1122
A1 Mark: 11
A2 Mark: 19
Exam Mark: 40
Next Node: 1189

...
\end{consolecode}

\subsection{Print singly linked list in reverse order}

In order to print the singly linked list in reverse order based on the student ID, the program must copy each node it traverses through to a temporary list. Since the program's existing insertion method \mintinline{bash}{insert_unit_result()} guarantees that the list will be in ascending order based on the student ID, the implementation of this method relies on \mintinline{bash}{insertFirst()} method to sort the temporary list in reverse order. In other words, the current node being copied will be inserted in front of the previous node copied, resulting in the temporary list being in descending order.

After all nodes are successfully copied, the method will then call to print the temporary list. A temporary list is used due to the structure of singly linked lists. If a temporary list is not used and pointers are modified in the actual list itself, references to the following nodes would be subsequently lost, and cause a loss in data.

Note that only the methods for the original \mintinline{bash}{UnitList} class will be displayed below, since the method for the alternative class is almost identical.

\subsubsection{Print singly linked list in reverse order algorithm}

To print in descending order each node in SLL headed by \emph{head} and currently sorted in ascending order:

\begin{enumerate}
\item If SLL is empty:
	\begin{enumerate}
	\item Terminate
	\end{enumerate}
\item Else let \emph{current} be node \emph{head}
\item Let \emph{temp} be a new temporary SLL
\item While \emph{current} is not null, repeat:
	\begin{enumerate}
	\item Insert \emph{current} in \emph{temp} SLL as first node
	\end{enumerate}
\item Print SLL \emph{temp}
\item Terminate
\end{enumerate}

\subsubsection{Print singly linked list in reverse order Java method}

\begin{listing}[H]
\caption{Delete target node method}
\begin{javacode}
private static void reverse_print_unit_result(UnitList u_list) {

    // if list is empty, print error message and terminate
    if(u_list == null) {
        System.out.println("Error: List is empty. No elements to print!");
        return;
    }

    // iterate through list until curr == null:
    for(UnitList curr = u_list; curr != null; curr = curr.next) {

        // call insertFirst through each iteration, storing list elements in reverse order
        insertFirst(u_list, curr.student_ID, curr.A1_result, curr.A2_result, curr.exam_result);
    }

    // print list in reverse order, stored in tempReverseList
    print_unit_result(tempReverseList);
}
\end{javacode}
\end{listing}

\noindent
Line 13 of Java code 3.3 calls \mintinline{bash}{insertFirst()} which copies the current node and inserts it as the first node in a new temporary SLL.

\subsubsection{Insert node as first node in singly linked list Java method}

\begin{listing}[H]
\caption{Insert first method}
\begin{javacode}
private static void insertFirst(UnitList u_list, int ID, int mark1, int mark2, int mark3) {

    // create new node called insert
    UnitList insert = new UnitList(ID, mark1, mark2, mark3);

    // if list is empty,
    if(u_list == null) {

        // make insert the first node
        tempReverseList = insert;

    // else list is not empty,
    } else {

        // set insert's next as tempReverseList's first node
        insert.next = tempReverseList;
        // copy insert into tempReverseList
        tempReverseList = insert;
    }

    // print action performed
    System.out.println("\nStudent " + ID + " inserted as first node.");
}
\end{javacode}
\end{listing}

\noindent
Java code 3.4 displays the \mintinline{bash}{insertFirst()} method which performs the copying function for each node into a temporary singly linked list.

\subsubsection{Print singly linked list in reverse order analysis}

Analysis of this algorithm involves counting traversals. At step 4 of the algorithm, each node in the original, ascending ordered list must be traversed in order to be copied into the temporary list, performing $n - 1$ traversals. Step 5 requires a secondary set of traversals of $n - 1$ to print each node in the temporary, descending ordered list. Therefore, time complexity of the algorithm is of $O(n^2)$.

At step 4.1, each node of the ascending ordered list must also be copied into the temporary, descending ordered list, performing $n - 1$ copies. Therefore, the algorithm's space complexity is of $O(n)$.

\newpage
\subsubsection{Print singly linked list in reverse order console output}

The following console output displays the singly linked list in its original ascending order.
\\
\begin{consolecode}
Student_No.: 1111
A1_mark: 17
A2_mark: 22
Exam_mark: 30

Student_No.: 1112
A1_mark: 10
A2_mark: 6
Exam_mark: 50

Student_No.: 1114
A1_mark: 14
A2_mark: 21
Exam_mark: 30

...

Student_No.: 1225
A1_mark: 17
A2_mark: 20
Exam_mark: 20
\end{consolecode}

\noindent
The following console output displays the singly linked list in descending order, after the execution of \mintinline{bash}{reverse_print_unit_result()}.
\\
\begin{consolecode}
Student_No.: 1225
A1_mark: 17
A2_mark: 20
Exam_mark: 20

Student_No.: 1189
A1_mark: 20
A2_mark: 30
Exam_mark: 50

Student_No.: 1145
A1_mark: 9
A2_mark: 16
Exam_mark: 20

...

Student_No.: 1111
A1_mark: 17
A2_mark: 22
Exam_mark: 30
\end{consolecode}